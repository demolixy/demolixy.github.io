<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>设计篇</title>
      <link href="/2019/07/10/she-ji-pian/"/>
      <url>/2019/07/10/she-ji-pian/</url>
      
        <content type="html"><![CDATA[<p>设计是把一种设想通过合理的规划，周密的计划，通过各种感觉形式传达出来的过程。设计是将目标更好变现的过程。回到软件设计上来，就体现在如何将软件高度抽象，解耦以达到分而治之的过程。<br>设计是如此重要，我们既要具备对事物的抽象，解耦能力，又要能够从细节上作把控，做到大处着眼，小处着手。对于方法论，软件设计领域也诞生了很多软件设计思想，比如面向过程设计，面向对象设计，面向服务设计，面向消息设计，面向失败设计等，每种思想也都是在企业软件发展不同阶段解决某个领域或某一类的问题，没有好与坏的区别。任何一点点的故障都可能带来严重的后果，因此面向失败设计显得尤为重要。我们需要横向从网络，dns，cdn，软负载，中间件，容器，存储，数据库等维度去梳理沉淀经验，也需要从纵向运维发布，监控报警，管控平台，调度，环境部署等维度梳理。 以下常用的参考指标：</p><p>编码设计 模块，服务，字段等设计的时候，需要考虑命名的可读性，见名知意，避免产生歧义。 接口设计需要满足开闭原则。<br>分布式设计 需要考虑一致性，避免脑裂问题产生。<br>缓存设计 确定命中率指标的前提下，需要持续观察未命中数据特征，特别是无效的查询，容易穿透缓存，命中数据库。<br>容量设计 自身稳态及尖刺容量评估确定的前提下，做好容量保护相应措施，比如限流，降级，隔离等<br>依赖设计 做好强弱依赖梳理，避免核心功能依赖非核心系统，非核心流程节点，能走异步最好走异步。<br>日志设计 系统日志尽可能异步化，尽量避免无效日志，控制台日志输出<br>监控设计 关键监控项及SLA的指标必须要做监控，监控项尽可能覆盖全，同时要做到有效报警，不要让大量无效报警淹没有价值的报警信息。<br>权限设计 本着够用原则，避免出现大权限，大账号，如果避免不了，需要做天花板限制。<br>表结构设计 分库分表需要考虑热点数据问题，时刻关注表的数据量大小</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>对象拷贝</title>
      <link href="/2019/06/19/dui-xiang-kao-bei/"/>
      <url>/2019/06/19/dui-xiang-kao-bei/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h3 id="1-拷贝方式"><a href="#1-拷贝方式" class="headerlink" title="1. 拷贝方式"></a>1. 拷贝方式</h3><h4 id="1-1-深拷贝"><a href="#1-1-深拷贝" class="headerlink" title="1.1 深拷贝"></a>1.1 深拷贝</h4><h4 id="1-2-浅拷贝"><a href="#1-2-浅拷贝" class="headerlink" title="1.2 浅拷贝"></a>1.2 浅拷贝</h4><h3 id="2-代码示例"><a href="#2-代码示例" class="headerlink" title="2. 代码示例"></a>2. 代码示例</h3><h4 id="2-1-common-io-BeanUtis"><a href="#2-1-common-io-BeanUtis" class="headerlink" title="2.1 common.io.BeanUtis"></a>2.1 <code>common.io.BeanUtis</code></h4><h4 id="2-2-org-springframework-beans-BeanUtils"><a href="#2-2-org-springframework-beans-BeanUtils" class="headerlink" title="2.2 org.springframework.beans.BeanUtils"></a>2.2 <code>org.springframework.beans.BeanUtils</code></h4><h4 id="2-3-Cglib-BeanCopier"><a href="#2-3-Cglib-BeanCopier" class="headerlink" title="2.3 Cglib BeanCopier"></a>2.3 <code>Cglib BeanCopier</code></h4><h3 id="3-性能分析"><a href="#3-性能分析" class="headerlink" title="3. 性能分析"></a>3. 性能分析</h3><h3 id="4-结论"><a href="#4-结论" class="headerlink" title="4. 结论"></a>4. 结论</h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>日期格式化（YYYY/MM/dd）</title>
      <link href="/2019/06/05/ri-qi-ge-shi-hua/"/>
      <url>/2019/06/05/ri-qi-ge-shi-hua/</url>
      
        <content type="html"><![CDATA[<p>日期格式化时，yyyy表示当天所在的年，而大写的YYYY代表是week in which year（JDK7之后引入的概念），意思是当天所在的周属于的年份，一周从周日开始，周六结束，只要本周跨年，返回的YYYY就是下一年。另外需要注意：</p><ul><li>表示月份是大写的M；</li><li>表示分钟则是小写的m；</li><li>24小时制的是大写的H；</li><li>12小时制的则是小写的h。</li></ul><p>正例：表示日期和时间的格式如下所示：<br> new SimpleDateFormat(“yyyy-MM-dd HH:mm:ss”);</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2019/05/10/wei-ming-ming/"/>
      <url>/2019/05/10/wei-ming-ming/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th></th><th>名称</th><th>wiki</th></tr></thead><tbody><tr><td>服务框架</td><td>HSF</td><td><a href="http://mw.alibaba-inc.com/products/hsf/_book/?spm=a1zco.detail-hsf.2853836.3.1c7c4ef0ZdudL9" target="_blank" rel="noopener">wiki</a></td></tr><tr><td>应用框架</td><td>Pandora Boot</td><td><a href="http://mw.alibaba-inc.com/products/pandoraboot/_book/?spm=a1zco.detail-pandoraboot.2853836.2.cced41aduAjVNm" target="_blank" rel="noopener">wiki</a></td></tr></tbody></table>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>TraceId 生成规则</title>
      <link href="/2019/05/09/traceid-sheng-cheng-gui-ze/"/>
      <url>/2019/05/09/traceid-sheng-cheng-gui-ze/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h3 id="1-背景介绍"><a href="#1-背景介绍" class="headerlink" title="1. 背景介绍"></a>1. 背景介绍</h3><p>在常用的日志系统中，都会生成一个唯一的标识，来标明本次请求的ID，所有具有一个实际业务含义的标识比UUID更加的具有可读性。</p><h3 id="2-实现说明"><a href="#2-实现说明" class="headerlink" title="2. 实现说明"></a>2. 实现说明</h3><p><strong><em>aaaaaaaatttttttttttttccccfpppp</em></strong></p><p>TraceId的a段是8个字符的IP地址（IPv4的每个段用两位16进制数表示），t段是13个字符的生成TraceId的毫秒时间，c段是4位（1000-9999）的整数递增量。对于线上环境，a段IP地址使用的最前端负责生成TraceId的那台服务器的IP，使用a、t、c三段能从TraceId直接得到机器IP和生成时间，能够满足直接根据机器IP 扫描检索TraceId的需求；时间也有助于TraceId的分布足够分散的同时又可以按时间进行存储分区。c段的4位顺序数用于避免多线程并发时TraceId碰撞（可以保证在qps=9000000以下不碰撞）。a、t、c三段的TraceId是现在用的最多的方案，但这个方案并不完美，如果同一台机器上同时部署多个应用，就很容易出现TraceId碰撞的情况，为了支持多JVM实例环境，最新版的 TraceId 末尾又增加了一个扩展字符 f （一般用于排查问题，例如f 段是字符e，表示由nginx模块生成的TraceId）和进程号p段（用四位16进制数表示）。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>哈希表</title>
      <link href="/2019/03/29/ha-xi-biao/"/>
      <url>/2019/03/29/ha-xi-biao/</url>
      
        <content type="html"><![CDATA[<p>根据键<code>key</code>而直接访问内存存储位置的数据结构，它通过计算一个关于键值的函数，将所需要查询的数据映射到表中一个位置来访问记录。可以加快查找的速度。这个映射函数称做散列函数，存放记录的数组称做散列表</p><h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1.基本概念"></a>1.基本概念</h3><h3 id="2-构造散列函数"><a href="#2-构造散列函数" class="headerlink" title="2.构造散列函数"></a>2.构造散列函数</h3><pre><code>· 直接地址法· 数字分析法· 平方取中法· 折叠法· 除留余数法</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>向下转型和自动包装</title>
      <link href="/2019/03/20/xiang-xia-zhuan-xing-he-zi-dong-bao-zhuang/"/>
      <url>/2019/03/20/xiang-xia-zhuan-xing-he-zi-dong-bao-zhuang/</url>
      
        <content type="html"><![CDATA[<h3 id="问题说明"><a href="#问题说明" class="headerlink" title="问题说明"></a>问题说明</h3><p>在debug的时候遇到一个傻逼的问题，排查很长时间没有找到具体的原因。最后发现使用<strong>判等2</strong>这种方式进行判断的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public boolean testNumEquals() &#123;</span><br><span class="line">    Long num1 = 0L;</span><br><span class="line">    int num = 0;</span><br><span class="line">    // 判等1</span><br><span class="line">    System.out.println(num == num1);</span><br><span class="line">    // 判等2</span><br><span class="line">    System.out.printlb(num1.equals(0));</span><br><span class="line">    // 判等3</span><br><span class="line">    System.out.println(num1.equals(0L));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">true;</span><br><span class="line">false;</span><br><span class="line">true;</span><br></pre></td></tr></table></figure></p><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><p>在分析之前需要说明几个关键的名字<strong>自动拆箱，自动装箱，隐式类型转化</strong> 进行说明。</p><ul><li><p>自动装箱：</p><blockquote><p>将基本类型转化为该基本类型的实际包装类</p></blockquote><blockquote><p>eg: int –&gt; Integer</p></blockquote></li><li>自动拆箱<blockquote><p>将包装类型转化为该包装类的基本类型</p></blockquote></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static void test() &#123;</span><br><span class="line">    int a = 1;</span><br><span class="line">    Integer a1 = new Intger(1);</span><br><span class="line">    System.out.println(a == a1);</span><br><span class="line">    System.out.println(a1.equals(a));</span><br><span class="line">&#125;</span><br><span class="line">out:</span><br><span class="line">true;</span><br><span class="line">true;</span><br></pre></td></tr></table></figure><h3 id="问题总结"><a href="#问题总结" class="headerlink" title="问题总结"></a>问题总结</h3><ol><li>进行<code>==</code> 操作的时候，会对Intger进行自动拆箱的操作，使用<code>Integer.equals(int)</code>进行比较的时候,会对<code>int</code>进行自动装箱的操作。</li><li>对于两个非new生成的Integer对象，进行比较时，如果两个变量的值在区间-128到127之间</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static Integer valueOf(int i) &#123;</span><br><span class="line">    if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        return IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    return new Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>对于<code>Integer i = 100;</code>的操作等同于<code>Ineger i = Integer.valueof(100)</code>;</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java异常体系结构</title>
      <link href="/2019/03/20/java-yi-chang-ti-xi-jie-gou/"/>
      <url>/2019/03/20/java-yi-chang-ti-xi-jie-gou/</url>
      
        <content type="html"><![CDATA[<h3 id="Java异常体系结构"><a href="#Java异常体系结构" class="headerlink" title="Java异常体系结构"></a>Java异常体系结构</h3><p><img src="https://note.youdao.com/yws/public/resource/7fc235c525305c0a08973cbf52212bc5/xmlnote/F8F814C1853543ECB84F66407E511C99/7121" alt="image"></p><h4 id="Throwable"><a href="#Throwable" class="headerlink" title="Throwable"></a>Throwable</h4><p>Thorwable类所有异常和错误的超类，有两个子类Error和Exception，分别表示错误和异常</p><h4 id="Exception"><a href="#Exception" class="headerlink" title="Exception"></a>Exception</h4><p>程序本身可以处理的异常，这种异常分两大类运行时异常和非运行时异常。<br>    程序中应当尽可能去处理这些异常。</p><ul><li><p>运行时异常</p><blockquote><p>运行时异常都是RuntimeException类及其子类异常，如NullPointerException、IndexOutOfBoundsException等，<br>这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，<br>程序应该从逻辑角度尽可能避免这类异常的发生。</p></blockquote></li><li><p>非运行时异常</p><blockquote><p>非运行时异常是RuntimeException以外的异常，类型上都属于Exception类及其子类。<br>从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。<br>如IOException、SQLException等以及用户自定义的Exception异常，一般情况下不自定义检查异常。</p></blockquote></li></ul><h4 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h4><p>Error是程序无法处理的错误，比如OutOfMemoryError、ThreadDeath等。这些异常发生时，<br>    Java虚拟机（JVM）一般会选择线程终止。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>springboot获取不到配置</title>
      <link href="/2019/03/20/springboot-huo-qu-bu-dao-pei-zhi/"/>
      <url>/2019/03/20/springboot-huo-qu-bu-dao-pei-zhi/</url>
      
        <content type="html"><![CDATA[<h3 id="问题现象"><a href="#问题现象" class="headerlink" title="问题现象"></a>问题现象</h3><ul><li>使用<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* 使用的代码从网上找的，大家都是这样写的，无任何特殊的配置</span><br><span class="line"></span><br><span class="line">### 源码示例</span><br></pre></td></tr></table></figure></li></ul><p>es:<br>  ip: 172.16.33.29<br>  port: 9201<br>  username: admin<br>  password: 123<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><pre><code>@Value(&quot;${es.ip}&quot;)private String esIp;@Value(&quot;${es.port}&quot;)private String esHttpPort;@Value(&quot;${es.username}&quot;)private String esUserName;@Value(&quot;$(es.password)&quot;)private String esUserPw;/** jestClient 实例化对象 */private JestClient jestClient;public EsInstance() {    initJestClient();}/** * 初始化ES */private void initJestClient() {    String url = &quot;http://&quot; + esIp + &quot;:&quot; + esHttpPort;    HttpClientConfig httpClientConfig = new HttpClientConfig.Builder(url)            .defaultCredentials(esUserName, esUserPw)            .build();    CredentialsProvider credentialsProvider = httpClientConfig.getCredentialsProvider();    HttpClientContext httpClientContextTemplate = HttpClientContext.create();    httpClientContextTemplate.setCredentialsProvider(credentialsProvider);    JestHttpClient clientWithMockedHttpClient;    JestClientFactory factory = new JestClientFactory();    factory.setHttpClientConfig(httpClientConfig);    clientWithMockedHttpClient = (JestHttpClient) factory.getObject();    jestClient = clientWithMockedHttpClient;}</code></pre><p><code>`</code></p><ul><li>此处获取的相关属性都是空的</li></ul><h3 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h3><ul><li>Spring在扫描注解的时候，当扫描到会进行new对象的操作，因为此类里面有默认无参构造器，所以会直接初始化<code>initJestClient</code>方法，但是此时属性注解还是没有注入进去，所以获取的值就是空的！！！</li></ul><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ul><li>当执行完Spring对象初始化的时候，才走这个初始化的方法</li></ul><h3 id="问题反思"><a href="#问题反思" class="headerlink" title="问题反思"></a>问题反思</h3><ul><li>原来那样写，是因为使用的是工具类获取，工具类已经缓存到所有的属性，在bean初始化之前就已经缓存好了</li></ul><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><ul><li><p>Spring Bean的生命周期</p><p><img src="https://note.youdao.com/yws/public/resource/7fc235c525305c0a08973cbf52212bc5/xmlnote/7C755F1ACCFE4BBC9E511AB294ECBB92/6879" alt="image"></p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Maven scope的几种类型</title>
      <link href="/2019/03/14/maven-scope-de-ji-chong-lei-xing/"/>
      <url>/2019/03/14/maven-scope-de-ji-chong-lei-xing/</url>
      
        <content type="html"><![CDATA[<h2 id="1-问题背景"><a href="#1-问题背景" class="headerlink" title="1 问题背景"></a>1 问题背景</h2><ul><li>在处理单元测试的时候，多个模块需要处理相同的单元测试逻辑，所以就将重复的逻辑给抽象出来，组成一个base，让各个基类实现各自的内容。</li></ul><h2 id="2-问题现象"><a href="#2-问题现象" class="headerlink" title="2 问题现象"></a>2 问题现象</h2><ul><li>但是集成的过程中发现始终import不进去base jar里面的内容</li></ul><h2 id="3-问题定位"><a href="#3-问题定位" class="headerlink" title="3 问题定位"></a>3 问题定位</h2><ul><li>最终定位是<code>pom.xml</code>依赖这个jar，他的scope是test，也就是说只有<code>test-source</code>才会import这个jar，正常的src是依赖不上的。</li></ul><h2 id="4-问题总结"><a href="#4-问题总结" class="headerlink" title="4 问题总结"></a>4 问题总结</h2><ul><li><p>本次问题还是对mvn的scope不太熟悉导致的。所以就将maven的几种scope给列出来，复习一下。</p></li><li><p>scope</p><blockquote><p>依赖范围控制哪些依赖在哪些classpath 中可用，哪些依赖包含在一个应用中。</p></blockquote></li><li><p>compile (编译范围)</p><blockquote><p>compile是默认的范围；如果没有提供一个范围，那该依赖的范围就是编译范围。编译范围依赖在所有的classpath 中可用，同时它们也会被打包。</p></blockquote></li><li><p>provided （已提供范围）</p><blockquote><p>provided 依赖只有在当JDK 或者一个容器已提供该依赖之后才使用。例如， 如果你开发了一个web 应用，你可能在编译 classpath 中需要可用的Servlet API 来编译一个servlet，但是你不会想要在打包好的WAR 中包含这个Servlet API；这个Servlet API JAR 由你的应用服务器或者servlet 容器提供。已提供范围的依赖在编译classpath （不是运行时）可用。它们不是传递性的，也不会被打包。</p></blockquote></li><li><p>runtime （运行时范围）</p><blockquote><p>runtime 依赖在运行和测试系统的时候需要，但在编译的时候不需要。比如，你可能在编译的时候只需要JDBC API JAR，而只有在运行的时候才需要JDBC驱动实现。</p></blockquote></li><li><p>test （测试范围）</p><blockquote><p>test范围依赖 在一般的编译和运行时都不需要，它们只有在测试编译和测试运行阶段可用。</p></blockquote></li><li><p>system （系统范围）</p><blockquote><p>system范围依赖与provided 类似，但是你必须显式的提供一个对于本地系统中JAR 文件的路径。这么做是为了允许基于本地对象编译，而这些对象是系统类库的一部分。这样的构件应该是一直可用的，Maven 也不会在仓库中去寻找它。如果你将一个依赖范围设置成系统范围，你必须同时提供一个 systemPath 元素。注意该范围是不推荐使用的（你应该一直尽量去从公共或定制的 Maven 仓库中引用依赖）。</p></blockquote></li><li><p>scope的依赖传递</p><blockquote><p>A–&gt;B–&gt;C。当前项目为A，A依赖于B，B依赖于C。知道B在A项目中的scope，那么怎么知道C在A中的scope呢？答案是： 当C是test或者provided时，C直接被丢弃，A不依赖C； 否则A依赖C，C的scope继承于B的scope。</p></blockquote></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java List中的clear 和 removeAll性能比较</title>
      <link href="/2019/03/14/java-list-zhong-de-clear-he-removeall-xing-neng-bi-jiao/"/>
      <url>/2019/03/14/java-list-zhong-de-clear-he-removeall-xing-neng-bi-jiao/</url>
      
        <content type="html"><![CDATA[<h3 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h3><p>有一个需求的场景就是，有个庞大的<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">计划每做一次写入的操作，对```List```进行一次清空的操作</span><br></pre></td></tr></table></figure></p><pre><code>public void clear() {    modCount++;    // clear to let GC do its work    for (int i = 0; i &lt; size; i++)        elementData[i] = null;    size = 0;}</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>public boolean removeAll(Collection&lt;?&gt; c) {<br>        return batchRemove(c, false);<br>    }</p><pre><code>private boolean batchRemove(Collection&lt;?&gt; c, boolean complement) {    final Object[] elementData = this.elementData;    int r = 0, w = 0;    boolean modified = false;    try {        for (; r &lt; size; r++)            if (c.contains(elementData[r]) == complement)                elementData[w++] = elementData[r];    } finally {        // Preserve behavioral compatibility with AbstractCollection,        // even if c.contains() throws.        if (r != size) {            System.arraycopy(elementData, r,                             elementData, w,                             size - r);            w += size - r;        }        if (w != size) {            // clear to let GC do its work            for (int i = w; i &lt; size; i++)                elementData[i] = null;            modCount += size - w;            size = w;            modified = true;        }    }    return modified;}   </code></pre><p><code>`</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>线程池</title>
      <link href="/2019/03/14/xian-cheng-chi/"/>
      <url>/2019/03/14/xian-cheng-chi/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ul><li>降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li><li>提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。</li><li>提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li></ul><h3 id="线程池的使用"><a href="#线程池的使用" class="headerlink" title="线程池的使用"></a>线程池的使用</h3><h4 id="1-线程池的创建"><a href="#1-线程池的创建" class="headerlink" title="1 线程池的创建"></a>1 线程池的创建</h4><p>通过ThreadPoolExecutor来创建一个线程池。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">new ThreadPoolExecutor(corePoolSize, maximumPoolSize,</span><br><span class="line">keepAliveTime, milliseconds,runnableTaskQueue, threadFactory,handler);</span><br></pre></td></tr></table></figure></p><ul><li>corePoolSize（线程池的基本大小）：当提交一个任务到线程池时，线程池会创建一个线程来执行任务，即使其他空闲的基本线程能够执行新任务也会创建线程，等到需要执行的任务数大于线程池基本大小时就不再创建。如果调用了线程池的prestartAllCoreThreads方法，线程池会提前创建并启动所有基本线程。</li><li><p>runnableTaskQueue（任务队列）：用于保存等待执行的任务的阻塞队列。可以选择以下几个阻塞队列。</p><ol><li><p><code>ArrayBlockingQueue</code>：是一个基于数组结构的有界阻塞队列，此队列按 FIFO（先进先出）原则对元素进行排序。</p></li><li><p><code>LinkedBlockingQueue</code>：一个基于链表结构的阻塞队列，此队列按FIFO （先进先出） 排序元素，吞吐量通常要高于<code>ArrayBlockingQueue</code>。静态工厂方法<code>Executors.newFixedThreadPool()</code>使用了这个队列。</p></li><li><p><code>SynchronousQueue</code>：一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于<code>LinkedBlockingQueue</code>，静态工厂方法<code>Executors.newCachedThreadPool</code>使用了这个队列。</p></li><li><code>PriorityBlockingQueue</code>：一个具有优先级得无限阻塞队列。</li><li></li></ol></li><li>maximumPoolSize（线程池最大大小）：线程池允许创建的最大线程数。如果队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。值得注意的是如果使用了无界的任务队列这个参数就没什么效果。</li><li><p>ThreadFactory：用于设置创建线程的工厂，可以通过线程工厂给每个创建出来的线程设置更有意义的名字，Debug和定位问题时非常又帮助。</p></li><li><p>RejectedExecutionHandler（饱和策略）：当队列和线程池都满了，说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务。这个策略默认情况下是AbortPolicy，表示无法处理新任务时抛出异常。以下是JDK1.5提供的四种策略。n  AbortPolicy：直接抛出异常。</p></li><li><p>keepAliveTime（线程活动保持时间）：线程池的工作线程空闲后，保持存活的时间。所以如果任务很多，并且每个任务执行的时间比较短，可以调大这个时间，提高线程的利用率。</p></li><li>TimeUnit（线程活动保持时间的单位）：可选的单位有天（DAYS），小时（HOURS），分钟（MINUTES），毫秒(MILLISECONDS)，微秒(MICROSECONDS, 千分之一毫秒)和毫微秒(NANOSECONDS, 千分之一微秒)。</li></ul><h4 id="2-线程池的关闭"><a href="#2-线程池的关闭" class="headerlink" title="2 线程池的关闭"></a>2 线程池的关闭</h4><ul><li><p>调用线程池的shutdown</p><ol><li>将线程池的状态设置成SHUTDOWN状态</li><li>中断所有没有正在执行任务的线程</li></ol></li><li><p>调用线程池的shutdownNow</p><ol><li>遍历线程池中的工作线程，然后逐个调用线程的interrupt方法来中断线程</li><li>无法响应中断的任务可能永远无法终止</li><li>将线程池的状态设置成STOP，然后尝试停止所有的正在执行或暂停任务的线程，并返回等待执行任务的列表</li></ol></li></ul><h3 id="线程池的分析"><a href="#线程池的分析" class="headerlink" title="线程池的分析"></a>线程池的分析</h3><p>流程分析：线程池的主要工作流程如下图：<br><img src="https://note.youdao.com/yws/public/resource/7fc235c525305c0a08973cbf52212bc5/xmlnote/BA2A990AAD4645D5A4E5BA77751AA363/7397" alt="线程池分析"></p><ol><li>首先线程池判断基本线程池是否已满？没满，创建一个工作线程来执行任务。满了，则进入下个流程。</li><li>其次线程池判断工作队列是否已满？没满，则将新提交的任务存储在工作队列里。满了，则进入下个流程。</li><li>最后线程池判断整个线程池是否已满？没满，则创建一个新的工作线程来执行任务，满了，则交给饱和策略来处理这个任务。</li></ol><h3 id="合理的配置线程池"><a href="#合理的配置线程池" class="headerlink" title="合理的配置线程池"></a>合理的配置线程池</h3><p>要想合理的配置线程池，就必须首先分析任务特性</p><ol><li>任务的性质：CPU密集型任务，IO密集型任务和混合型任务。</li><li>任务的优先级：高，中和低。</li><li>任务的执行时间：长，中和短。</li><li>任务的依赖性：是否依赖其他系统资源，如数据库连接。</li></ol><h4 id="1-任务的性质"><a href="#1-任务的性质" class="headerlink" title="1 任务的性质"></a>1 任务的性质</h4><ul><li><p>CPU密集型任务</p><blockquote><p>要进行大量的计算，消耗CPU资源，比如计算圆周率、对视频进行高清解码等等，全靠CPU的运算能力。</p></blockquote><blockquote><p>任务越多，花在任务切换的时间就越多，CPU执行任务的效率就越低</p></blockquote><blockquote><p>配置尽可能少的线程数量，如配置Ncpu+1个线程的线程池</p></blockquote></li><li><p>IO密集型任务</p><blockquote><p>涉及到网络、磁盘IO的任务都是IO密集型任务，这类任务的特点是CPU消耗很少，任务的大部分时间都在等待IO操作完成</p></blockquote><blockquote><p>等待IO操作，线程并不是一直在执行任务，则配置尽可能多的线程，如2*Ncpu。</p></blockquote></li><li><p>混合型的任务</p><blockquote><p>如果两个任务执行的时间相差不是太大，可以拆分成CPU密集型任务和一个IO密集型任务</p></blockquote><blockquote><p>并行执行的吞吐率要高于串行执行的吞吐率</p></blockquote></li></ul><h4 id="2-任务的优先级"><a href="#2-任务的优先级" class="headerlink" title="2 任务的优先级"></a>2 任务的优先级</h4><ul><li><p>使用优先级队列<code>PriorityBlockingQueue</code></p><blockquote><p>它可以让优先级高的任务先得到执行，需要注意的是如果一直有优先级高的任务提交到队列里，那么优先级低的任务可能永远不能执行。</p></blockquote></li></ul><h4 id="3-任务的执行时间"><a href="#3-任务的执行时间" class="headerlink" title="3 任务的执行时间"></a>3 任务的执行时间</h4><ul><li>执行时间不同的任务可以交给不同规模的线程池来处理，或者也可以使用优先级队列，让执行时间短的任务先执行。</li></ul><h4 id="4-任务的依赖性"><a href="#4-任务的依赖性" class="headerlink" title="4 任务的依赖性"></a>4 任务的依赖性</h4><ul><li>依赖数据库连接池的任务，因为线程提交SQL后需要等待数据库返回结果，如果等待的时间越长CPU空闲时间就越长，那么线程数应该设置越大，这样才能更好的利用CPU。</li></ul><h3 id="线程池的监控"><a href="#线程池的监控" class="headerlink" title="线程池的监控"></a>线程池的监控</h3><p>通过线程池提供的参数进行监控。线程池里有一些属性在监控线程池的时候可以使用</p><ol><li><p>taskCount：线程池需要执行的任务数量。</p></li><li><p>completedTaskCount：线程池在运行过程中已完成的任务数量。小于或等于taskCount。</p></li><li><p>largestPoolSize：线程池曾经创建过的最大线程数量。通过这个数据可以知道线程池是否满过。如等于线程池的最大大小，则表示线程池曾经满了。</p></li><li><p>getPoolSize:线程池的线程数量。如果线程池不销毁的话，池里的线程不会自动销毁，所以这个大小只增不减。</p></li><li>getActiveCount：获取活动的线程数。</li></ol><h4 id="扩展线程池"><a href="#扩展线程池" class="headerlink" title="扩展线程池"></a>扩展线程池</h4><p>通过继承线程池并重写线程池的beforeExecute，afterExecute和terminated方法，我们可以在任务执行前，执行后和线程池关闭前干一些事情。如监控任务的平均执行时间，最大执行时间和最小执行时间等。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ES</title>
      <link href="/2019/03/14/es-cao-zuo/"/>
      <url>/2019/03/14/es-cao-zuo/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1 介绍"></a>1 介绍</h2><ul><li>分布式 可扩展 实时的搜索引擎</li><li>接近实时<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">* 支持多种客户端</span><br><span class="line">* 强大的统计功能</span><br><span class="line">* ```RESTful``` ```Api``` 接口</span><br><span class="line"></span><br><span class="line">## 2 使用场景</span><br><span class="line">* 全文检索</span><br><span class="line">* 结构化检索</span><br><span class="line">* 数据分析</span><br><span class="line">* ```NoSQL``` ```Json``` 文档数据库</span><br><span class="line">### 2.1 材料分析使用场景</span><br><span class="line">* 文档数据存储（存储文本的结构化数据）</span><br><span class="line">* 文本搜索（关键字搜索）</span><br><span class="line">* 数据统计（用户使用习惯统计）</span><br><span class="line"></span><br><span class="line">## 3 如何部署</span><br><span class="line">### 3.1 服务端</span><br><span class="line">支持linux和window平台部署</span><br><span class="line">* 硬件要求</span><br><span class="line">    &gt; 内存要求比较高，排序和聚合比较好内存</span><br><span class="line"></span><br><span class="line">    &gt; 硬盘尽可能快</span><br><span class="line"></span><br><span class="line">    &gt; cpu要求不高，核数多，支持的并发就多</span><br><span class="line">* 操作系统</span><br><span class="line">    &gt; 推荐部署在linux下。 （磁盘阵列）???</span><br><span class="line">* JDK</span><br><span class="line">    &gt; JDK 1.7 + </span><br><span class="line">* 部署配置说明</span><br><span class="line">    &gt; ```1.7.5``` 部署说明</span><br></pre></td></tr></table></figure></li></ul><p>cluster.name: clfx-test<br>配置es的集群名称，默认是elasticsearch，es会自动发现在同一网段下的es，如果在同一网段下有多个集群，就可以用这个属性来区分不同的集群。<br>node.name: “data-0”<br>节点名，默认随机指定一个name列表中名字，该列表在es的jar包中config文件夹里name.txt文件中，其中有很多作者添加的有趣名字。<br>node.master: true<br>指定该节点是否有资格被选举成为node，默认是true，es是默认集群中的第一台机器为master，如果这台机挂了就会重新选举master。<br>node.data: true<br>指定该节点是否存储索引数据，默认为true。<br>index.number_of_shards: 5<br>设置默认索引分片个数，默认为5片。<br>index.number_of_replicas: 1<br>设置默认索引副本个数，默认为1个副本。<br>path.conf: /path/to/conf<br>设置配置文件的存储路径，默认是es根目录下的config文件夹。<br>path.data: /path/to/data<br>设置索引数据的存储路径，默认是es根目录下的data文件夹，可以设置多个存储路径，用逗号隔开，例：<br>path.data: /path/to/data1,/path/to/data2<br>path.work: /path/to/work<br>设置临时文件的存储路径，默认是es根目录下的work文件夹。<br>path.logs: /path/to/logs<br>设置日志文件的存储路径，默认是es根目录下的logs文件夹<br>path.plugins: /path/to/plugins<br>设置插件的存放路径，默认是es根目录下的plugins文件夹<br>bootstrap.mlockall: true<br>设置为true来锁住内存。因为当jvm开始swapping时es的效率会降低，所以要保证它不swap，可以把ES_MIN_MEM和 ES_MAX_MEM两个环境变量设置成同一个值，并且保证机器有足够的内存分配给es。同时也要允许elasticsearch的进程可以锁住内存，linux下可以通过<code>ulimit -l unlimited</code>命令。<br>network.bind_host: 192.168.0.1<br>设置绑定的ip地址，可以是ipv4或ipv6的，默认为0.0.0.0。<br>network.publish_host: 192.168.0.1<br>设置其它节点和该节点交互的ip地址，如果不设置它会自动判断，值必须是个真实的ip地址。<br>network.host: 192.168.0.1<br>这个参数是用来同时设置bind_host和publish_host上面两个参数。<br>transport.tcp.port: 9300<br>设置节点间交互的tcp端口，默认是9300。<br>transport.tcp.compress: true<br>设置是否压缩tcp传输时的数据，默认为false，不压缩。<br>http.port: 9200<br>设置对外服务的http端口，默认为9200。<br>http.max_content_length: 100mb<br>设置内容的最大容量，默认100mb<br>http.enabled: false<br>是否使用http协议对外提供服务，默认为true，开启。<br>gateway.type: local<br>gateway的类型，默认为local即为本地文件系统，可以设置为本地文件系统，分布式文件系统，Hadoop的HDFS，和amazon的s3服务器。<br>gateway.recover_after_nodes: 1<br>设置集群中N个节点启动时进行数据恢复，默认为1。<br>gateway.recover_after_time: 5m<br>设置初始化数据恢复进程的超时时间，默认是5分钟。<br>gateway.expected_nodes: 2<br>设置这个集群中节点的数量，默认为2，一旦这N个节点启动，就会立即进行数据恢复。<br>cluster.routing.allocation.node_initial_primaries_recoveries: 4<br>初始化数据恢复时，并发恢复线程的个数，默认为4。<br>cluster.routing.allocation.node_concurrent_recoveries: 2<br>添加删除节点或负载均衡时并发恢复线程的个数，默认为4。<br>indices.recovery.max_size_per_sec: 0<br>设置数据恢复时限制的带宽，如入100mb，默认为0，即无限制。<br>indices.recovery.concurrent_streams: 5<br>设置这个参数来限制从其它分片恢复数据时最大同时打开并发流的个数，默认为5。<br>discovery.zen.minimum_master_nodes: 1<br>设置这个参数来保证集群中的节点可以知道其它N个有master资格的节点。默认为1，对于大的集群来说，可以设置大一点的值（2-4）<br>discovery.zen.ping.timeout: 3s<br>设置集群中自动发现其它节点时ping连接超时时间，默认为3秒，对于比较差的网络环境可以高点的值来防止自动发现时出错。<br>discovery.zen.ping.multicast.enabled: false<br>设置是否打开多播发现节点，默认是true。<br>discovery.zen.ping.unicast.hosts: [“host1”, “host2:port”, “host3[portX-portY]”]<br>设置集群中master节点的初始列表，可以通过这些节点来自动发现新加入集群的节点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* 分词插件</span><br><span class="line">    &gt; IK分词</span><br><span class="line"></span><br><span class="line">```http://172.16.33.29:9201/_analyze?text=%E6%9D%90%E6%96%99%E5%88%86%E6%9E%90</span><br></pre></td></tr></table></figure><h3 id="3-2-客户端"><a href="#3-2-客户端" class="headerlink" title="3.2 客户端"></a>3.2 客户端</h3><p>客户端采用1.7.5</p><ul><li><p>Java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Settings settings = ImmutableSettings.settingsBuilder()</span><br><span class="line">        .put(&quot;cluster.name&quot;, clusterName)</span><br><span class="line">        .put(&quot;client.transport.sniff&quot;, true).build();</span><br><span class="line">Esclient esClient = new TransportClient(settings)</span><br><span class="line">        .addTransportAddress(new InetSocketTransportAddress(ip,</span><br><span class="line">                port));</span><br></pre></td></tr></table></figure></li><li><p>HTTP</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PUT /megacorp/employee/1</span><br><span class="line">&#123;</span><br><span class="line">    &quot;first_name&quot; : &quot;John&quot;,</span><br><span class="line">    &quot;last_name&quot; :  &quot;Smith&quot;,</span><br><span class="line">    &quot;age&quot; :        25,</span><br><span class="line">    &quot;about&quot; :      &quot;I love to go rock climbing&quot;,</span><br><span class="line">    &quot;interests&quot;: [ &quot;sports&quot;, &quot;music&quot; ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-存储结构"><a href="#4-存储结构" class="headerlink" title="4 存储结构"></a>4 存储结构</h2><h3 id="4-1-document"><a href="#4-1-document" class="headerlink" title="4.1 document"></a>4.1 document</h3><ul><li>文档<blockquote><p>一个文档是可以被索引的最基本的单位。<br>文档相当于关系型数据库中的row，也就是一行行的数据。<br>例如一个用户可以是一个文档，一个产品可以是一个文档，一条订单记录可以是一个文档。一般用作json格式来展示。</p></blockquote></li></ul><h3 id="4-2-index"><a href="#4-2-index" class="headerlink" title="4.2 index"></a>4.2 index</h3><ul><li>索引<blockquote><p>index 是一些列具有相同特性的文档的集合。类似于关系型数据库中的库。<br>举例说明，你可以为客户数据创建索引，可以为产品目录创建索引，也可以为其他任何数据创建索引。<br>需要注意的是，index name 必须为小写字母 ，通常索引的名称会用在索引数据，搜索，更新或者删除数据的地方。</p></blockquote></li></ul><h3 id="4-3-type"><a href="#4-3-type" class="headerlink" title="4.3 type"></a>4.3 type</h3><ul><li>类型<blockquote><p>在一个索引中，你可以定义多个 type ，type 是索引中的逻辑分类。当然这个type的意义完全取决于你。<br>type 相当于关系型数据数据库中的表。<br>举例来说，在一个博客系统中，你可以定义一个 user type,可以定义一个 blog type,还可以定义一个 comment type。</p></blockquote></li></ul><h3 id="4-4-Cluser"><a href="#4-4-Cluser" class="headerlink" title="4.4 Cluser"></a>4.4 Cluser</h3><ul><li>聚集<blockquote><p>cluser 也称聚集，是由一个或者多个 node 组成的集合，保存了你所有的数据并且为所有节点提供索引及搜索的能力。cluser 的名称唯一。在聚集中，你可以有一个或者多个 node</p></blockquote><h3 id="4-5-Node"><a href="#4-5-Node" class="headerlink" title="4.5 Node"></a>4.5 Node</h3></li><li>节点<blockquote><p>一个 node 是一个单个服务器，属于 cluser 的一部分，提供了索引及搜索的能力。和 cluser 一样, node 也是通过名字来确保唯一性的。当 node 启动时，会生成一个随机的字符作为 node 的名字。<br>node 可以通过配置进而加入到特定的 cluser 中。默认的话会被加入到 elasticsearch 这个 cluster。</p></blockquote></li></ul><h3 id="4-6-Shards"><a href="#4-6-Shards" class="headerlink" title="4.6 Shards"></a>4.6 Shards</h3><ul><li><p>碎片</p><blockquote><p>一个索引可能会存储大量的数据，进而会让单个节点超出硬件能承受范围。举例来说，存储了10亿文档的单个节点，会占用1TB磁盘空间，并且会导致查询的时候速度很慢。<br>为了解决这个问题，Elasticsearch 提供了 碎片 也就是 shards 对 index 进行划分成更小的部分。 当你创建 index 的时候，你可以简单地指定你想要的碎片数量。每一个碎片具有和 index 完全相同的功能。</p></blockquote><p>  碎片最主要的两个作用是：</p><blockquote><p>它允许你水平地切割你的容量体积，它允许你并行地分发作业，提高系统的性能</p></blockquote></li></ul><h3 id="4-7-Replicas"><a href="#4-7-Replicas" class="headerlink" title="4.7 Replicas"></a>4.7 Replicas</h3><ul><li><p>副本</p><blockquote><p>因为各种原因，所以数据丢失等问题会时有发生，碎片也可能会丢失，为了防止这个问题，所以你可以将一个或多个索引碎片复制到所谓的复制碎片，简称为副本</p></blockquote><p>  副本最主要的两个作用是：</p><blockquote><p>它提供了高可用性,以防碎片/节点失败。之于这点，所以副本的永远不要和原始碎片分布在同一个节点上。<br>它可以扩展系统的吞吐量，因为搜索可以在所有副本执行。=<br>总的来说，每个 index 可以被分布到不同的碎片中，节点 可以有0个或者多个副本。一旦复制了，那么 index 就拥有一个主要的碎片和一个复制的碎片。碎片的数量和副本的数量可以在创建索引之前定义，在索引创建之后，你可以动态地改变副本的数量，但是却不能改变碎片的数量。<br>默认情况下，Elasticsearch 为每个索引分配了5个主碎片和1个副本，这意味着在你的集群中，如果至少有两个节点，那么每个索引将有5个主碎片和5个复制碎片，总共10碎片/索引。</p></blockquote></li></ul><h2 id="5-API"><a href="#5-API" class="headerlink" title="5 API"></a>5 API</h2><h3 id="5-1-增"><a href="#5-1-增" class="headerlink" title="5.1 增"></a>5.1 增</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">JSONObject json = new JSONObject();</span><br><span class="line">json.put(&quot;name&quot;, &quot;张三2222&quot;);</span><br><span class="line">json.put(&quot;sex&quot;, &quot;男&quot;);</span><br><span class="line">json.put(&quot;age&quot;, &quot;25&quot;);</span><br><span class="line">instance.getElasticWriter().index(&quot;lixiangyangtest&quot;, &quot;qaht_type_wsinfo&quot;, &quot;1113333333333333&quot;, json.toJSONString(), true);</span><br></pre></td></tr></table></figure><h3 id="5-2-删"><a href="#5-2-删" class="headerlink" title="5.2 删"></a>5.2 删</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">esInstance.getElasticWriter().delete(&quot;qaht_index_backfill&quot;, &quot;clfx_qaht_type_backfill_field&quot;,</span><br><span class="line">    hit.getId());</span><br></pre></td></tr></table></figure><h3 id="5-3-改"><a href="#5-3-改" class="headerlink" title="5.3 改"></a>5.3 改</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">查完在存储</span><br></pre></td></tr></table></figure><h3 id="5-4-查"><a href="#5-4-查" class="headerlink" title="5.4 查"></a>5.4 查</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GetResponse response = esinstace.getElasticReader().searchByID(index, wstype, cBh);</span><br><span class="line">String jsonStr = response.getSourceAsString();</span><br></pre></td></tr></table></figure><h2 id="6-开发建议"><a href="#6-开发建议" class="headerlink" title="6 开发建议"></a>6 开发建议</h2><h3 id="6-1-索引"><a href="#6-1-索引" class="headerlink" title="6.1 索引"></a>6.1 索引</h3><ul><li>功能描述_index_v版本号</li><li>所有索引必须要创建别名，创建别名之后不能修改</li><li>时间类型用long类型的存储</li><li>最好index里面只创建一个type</li><li>创建索引时，必须要创建mapping，指定好每一个字段的属性</li></ul><h3 id="6-2-搜索Api"><a href="#6-2-搜索Api" class="headerlink" title="6.2 搜索Api"></a>6.2 搜索Api</h3><ul><li>org.elasticsearch.index.query.QueryBuilders.termQuery(String, String)</li></ul><p>term是代表完全匹配，即不进行分词器分析，文档中必须包含整个搜索的词汇，但是ES存储field的分词属性不能设置</p><ul><li>matchPhraseQuery<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match_phrase&quot;: &#123;</span><br><span class="line">        &quot;content&quot; : &#123;</span><br><span class="line">            &quot;query&quot; : &quot;我的宝马多少马力&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>完全匹配</p><ul><li>matchQuery<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match&quot;: &#123;</span><br><span class="line">        &quot;content&quot; : &#123;</span><br><span class="line">            &quot;query&quot; : &quot;我的宝马多少马力&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>上面的查询匹配就会进行分词，比如”宝马多少马力”会被分词为”宝马 多少 马力”, 所有有关”宝马 多少 马力”, 那么所有包含这三个词中的一个或多个的文档就会被搜索出来。</p><ul><li><p>boolQuery</p><blockquote><p>must 相当于SQl里面的AND </p></blockquote><blockquote><p>should 相当于SQL里面的OR</p></blockquote></li></ul><h2 id="7-问题"><a href="#7-问题" class="headerlink" title="7 问题"></a>7 问题</h2><ul><li><p>重迁索引</p><blockquote></blockquote></li><li><p>分布式事务</p><blockquote><p><a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/concurrency-solutions.html" target="_blank" rel="noopener">对单个文件的变更是可以支持事务的</a></p></blockquote><blockquote><p>但是包含多个文档的变更不支持</p></blockquote></li><li><p>版本升级</p><blockquote><p>进行数据迁移，数据量大怎么迁移</p></blockquote></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MAVEN 操作相关</title>
      <link href="/2018/01/01/maven/"/>
      <url>/2018/01/01/maven/</url>
      
        <content type="html"><![CDATA[<h2 id="mvn简单说明"><a href="#mvn简单说明" class="headerlink" title="mvn简单说明"></a>mvn简单说明</h2><ol><li>本地仓库</li><li>maven私服仓库</li></ol><h3 id="1-mvn-install"><a href="#1-mvn-install" class="headerlink" title="1. mvn install"></a>1. mvn install</h3><p>将编译打包之后的jar，部署到本地maven仓库    </p><h3 id="2-mvn-package"><a href="#2-mvn-package" class="headerlink" title="2. mvn package"></a>2. mvn package</h3><p>只是打包部署到target下面，没有部署的本地的maven仓库</p><h3 id="3-mvn-deploy"><a href="#3-mvn-deploy" class="headerlink" title="3. mvn deploy"></a>3. mvn deploy</h3><p>打包部署到本地maven仓库和远程的私服仓库</p>]]></content>
      
      
      
        <tags>
            
            <tag> MAVEN </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
